---
layout: post
title: 技术 Swift计算器的设计逻辑
---

# 技术 Swift计算器的设计逻辑

教授iOS 开发的Stanford Paul Hegarty老师，大约在2017年的课程中讲过用swift写计算器app的例子，后来，特别是在iOS开发从MVC框架，转到MVVM框架上来的时候，他已经不再使用这个例子。

但我个人认为，计算器的设计逻辑，对于理解swift语言，是一个很好的入门例子，它比较简单(虽然从完整app的角度，其实一点都不简单)，能比较快地写出demo。

下面的内容里面，如果有不准确的地方，是由于我个人的理解。这个文章会持续更新和修改。

## 大的框架定义：

```swift
struct Cal {
	// 定义一个内部的参与计算的变量，这个变量从外部无法访问，只能从内部设定
	private var accmulator: Double? 
	
	// 计算引擎函数
	func perform(_ symbol: String) {
	
	}
	
	// 赋值函数，它负责把外部值赋给内部变量，因为内部变量可变，所以它是mutating
	mutating func setOperand(_ operand: Double) {
		accumulator = operand
	}
	
	// 结果取值接口，它对外暴露，并且通过 get 设定为当前结果只读模式
	var result: Double {
		get {
		    return accumulator!
		}
	}
}

```

上面是一个经典的数据处理引擎的设计方式。

这种设计方式的好处是：
* 易于测试。内部运算变量的值肯定是通过 setOperand这个接口被设定的，而不会是由其它调用函数的设定。对于追踪来源很明确。
* 它的结果是只读的，也就是说，这个结果肯定是在函数的内部产生的，不会被外部干扰和修改。
* 进和出，保持一致。

针对上述代码的外部调用方式示例：

```swift
private var brain = Cal()

//传入变量，计算器上显示的数值
brain.setOperand(displayValue)

//执行计算
brain.performOperation(symbol)

//如果有计算结果
if let result = braind.result {
	displayValue = result
}
```

## 计算引擎核心部分的设计：

### switch case

```swift
struct Cal {
	private var accmulator: Double? 
	
	mutating func perform(_ symbol: String) {
		switch symbol {
			case "pi":
				accumulator = Double.pi
			default: 
				break
			}
		}
```

一个最mini的演示版本已经可以运行。

上述演示版本，存在的明显问题：

如果要加更多的操作，只能增加更多的switch case；

可以处理直接得出结果的 Double.pi, 但如果类似 5*4=20，参数该如何传入？

### dictionary

先解决第一个部分，重复添加switch case的问题：

首先的想法就是，设计一个表格，把对应的操作存储在里面，使用的时候在表格中查询对应的操作。

在swift中，使用Dictionary来承担上述表格的角色。

```swift
private var operations: Dictionary<String, Double> = 
[
	"pi" : Double.pi, 
	"e" : M_E
]

mutating func perform(_ symbol: String) {
	if let constant = operations[symbol] {
		accumulator = constant
	}
}
```

这样就完成了字典的设计。
因为字典可以是任何类型，所以在 <> 指明了对应的类型 String 和 Double。
通过把常量加入到字典里的方式，比上面的 switch case 要简洁一些。




待续写
post status: in progress

tag: 编程 python swift
